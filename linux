* ყველა ფაილს.
f*.jpg ყველა ფაილს, რომლების f-ით იწყება და მთავრდება .jpg-ით.
Documents/* Documents დირექტორიის ყველა ფაილს.
*abc* ყველა ფაილს, რომელის დასახელებაშიც abc შედის. აქ თვითონ abc
ფაილიც იგულისხმება, რადგან * ასო-ნიშანთა ნულოვან წყობასაც
გულისხმობს.
?? ყველა ფაილს, რომლის დასახელებაც მხოლოდ 2 ასო-ნიშანია.
[abc]* ყველა ფაილს, რომლებიც იწყება a-თი ან b-თი ან c-თი.
[^abc]* ყველა ფაილს, რომლებიც იწყება არა a-თი ან არა b-თი ან არა c-თი.
[a-cst]* ყველა ფაილს, რომლებიც იწყება ან a-დან c-ს ჩათვლით ერთ-ერთი ასო-
ნიშნით, ან s-ით და ან t-თი.
[![:digit:]]* ყველა ფაილს, რომლებიც არ იწყება ციფრით.
{abc,def}* ყველა ფაილს, რომლებიც იწყება abc-თი ან def-თი.
{1..15} 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.
{1..15..2} 1, 3, 5, 7, 9, 11, 13, 15.
{b..f} b, c, d, e, f.
{f..b} f, e, d, c, b.
{m..a..3} m, j, g, d, a.

	[A-KQ-Z]*.{png,jpg,bmp}
ყველა ფაილს, რომლებიც A-დან K-მდე ან Q-დან Z-მდე ინტერვალით
იწყება და აქვს შემდეგი გაფართოება: png, jpg და ან bmp.
	*.{[jJ][pP][gG],[bB][mM][pP]}
ყველა ფაილს, რომლის გაფართოებაც არის jpg ან bmp, დიდი ან
პატარა ან შერეული ასოებით მოცემული.

Creating Files
	touch file{0..9}.{txt,TXT}

ახლა შექმნილი ფაილებიდან შევეცადოთ გამოვიტანოთ მხოლოდ ისინი, რომლებიც
განთავსებულია დირექტორიებში, რომელთა დასახელებაც არ შეიცავს ციფრს, B, E და F
ასოებს და თავად ფაილის გაფართოება კი მხოლოდ დიდ X შეიცავს, პატარას არა.
	ls [^0-9BEF][!0-9BEF]/*.?X?

მოდით, წავშალოთ ზემოთ შექმნილი ორ ასო-ნიშნიანი დირექტორიები და ფაილები:
	rm -rf file* ??

ბრძანებების შეერთებისთვის, ერთ ხაზში ჩაწერისა და გაშვებისთვის, ლინუქსში
რამდენიმე ოპერატორი გამოიყენება. ესენია:
	; წერტილ-მძიმე
	&& ლოგიკური და
	|| ლოგიკური ან


ფილტრი ბრძანებები (ფილტრები) ხშირად გამოიყენება მონაცემებზე რთული
ოპერაციების განსახორციელებლად მისი რამდენჯერმე გამოყენებით. მოდით, sort ბრძანების
გამოყენება ვცადოთ. ვთქვათ, გვსურს /bin და /usr/bin დირექტორიებში არსებული
ბრძანებების გამოტანა, მათი დახარისხება ანბანის მიხედვით (სორტირება) და ისე ნახვა:
	achiko@debian:∼$ ls /bin /usr/bin | sort | less
ბრძანება uniq ხშირად გამოიყენება sort-თან კომბინაციაში და დახარისხებული
ხაზებიდან მას გამოაქვს უნიკალური (ყველასგან განსხვავებული) ხაზები.
	achiko@debian:∼$ ls /bin /usr/bin | sort | uniq | less

შეგვიძლია ფაილის ნაცვლად ბრძანება wc-ს სხვა ბრძანების გამოსასვლელი
გადავცეთ მილით და ვნახოთ, რამდენი უნიკალური ხაზი, ანუ უნიკალური ბრძანება გვაქვს
/bin და /usr/bin დირექტორიებში.
	ls /bin /usr/bin | sort | uniq | wc -l
grep ბრძანებით შეგვიძლია დამატებით გავფილტროთ ჩვენი სია და ეკრანზე
მხოლოდ ის ხაზები გამოვიტანოთ, რომლებიც დასახელებაში გარკვეულ გამოსახულებას
შეიცავს, მაგალითად zip-ს.
	ls /bin /usr/bin | sort | uniq | grep "zip"

	achiko@debian:∼$ whoami
	achiko
id ბრძანება მომხმარებლის იდენტობის შესახებ უფრო მეტ ინფორმაციას გვანახებს.
	achiko@debian:∼$ id
	uid=1000(achiko) gid=1000(achiko) groups=1000(achiko),
	24(cdrom), 25(floppy),29(audio),44(video),115(scanner)


ნაგულისხმევი მნიშვნელობით, ps პროცესებს PID-ის მიხედვით ახარისხებს. --sort ოფციით ჩვენ შეგვიძლია, სურვილის მიხედვით, დახარისხების წესი შევცვალოთ პროცესორის 	გამოყენებადობის მიხედვით ასე:
	ps aux --sort -pcpu
მეხსიერების გამოყენებადობის მიხედვით ასე:
	ps aux --sort -pmem

ლოკალური ცვლადი გარემოს ცვლადად რომ გადავაქციოთ, შექმნის შემდეგ ის გარემოში უნდა დავაექსპორტოთ export ბრძანებით, ასე:
	export Var
ან პირდაპირ, შექმნისთანავე გავაკეთოთ, ასე:
	export Var="value"
ცვლადის მნიშვნელობის სანახავად echo ბრძანება გამოიყენება და ცვლადის სახელს წინ $(დოლარის ნიშანი) წარემძღვარება.
	echo $Var
	value

გარემოს ცვლადების სრული ჩამონათვალის სანახავად, თავისი მნიშვნელობებით, უნდა გავუშვათ ბრძანება printenv ან env არგუმენტების გარეშე.

ბრძანება head-ს ფაილის საწყისი ნაწილი გამოაქვს, tail ბრძანებას - ბოლო ნაწილი.

ეკრანზე ხაზების სასურველი რაოდენობის გამოსატანად -n ოფცია უნდა გამოვიყენოთ.
პირველი 3 ხაზის გამოტანა თუ გვსურს, ბრძანება ასე უნდა ჩავწეროთ:
	cat /etc/passwd | head -n 3

tr ბრძანებით შეგვიძლია, შევქმნათ მარტივი შემთხვევითი პაროლების გენერატო
	cat /dev/urandom | tr -dc ?A-Za-z-0-9 | head -c8; echo
	dgAqC1Xachiko@debian:∼$ cat /dev/urandom | tr -dc ?A-Za-z-0-9 | head -c8; echo
	JKA?5k8x
ამ შემთხვევაში, 8 სიმბოლოიანი პაროლების შემადგენელ ასოებად აღებული გვა	დიდი და პატარა ასოები, ციფრები, ტირე, ქვედა ტირე და კითხვის ნიშანი. შეგვიძლია პაროლ 	სიგრძე გავზარდოთ და სირთულისთვის მასში სხვა სიმბოლოებიც დავამატოთ.
	$ cat /dev/urandom | tr -dc ?\!@\#$%\(\)A-Za-z-0-9 | head -c12; echo
	u#24ks%cktHQ
	$ cat /dev/urandom | tr -dc ?\!@\#$%\(\)A-Za-z-0-9 | head -c12; echo
	ARkrCGWZ#)v!

ეს ბრძანება ჩვენს პირად დირექტორიაში არსებულ ყველა ფაილს გვანახებს ეკრანზე.
სია, სავარაუდოდ, გრძელი იქნება. მოდით, დავთვალოთ ისინი:
	find ∼ | wc -l
	839

-b ოფციით du ბრძანება ბაიტებში გვანახებს ფაილის რეალურ ზომებს.

როდესაც ფაილების ზუსტი ზომა არ ვიცით და გვსურს მისი მოძებნა ზომის მიხედვით,
შეგვიძლია + ან - ნიშანი ვიხმაროთ, რომელიც მოცემულ ზომაზე მეტს ან ნაკლებს ნიშნავს
მოძებნის პროცესში.
	find ∼ -type f -size +1M
ეს მოგვიძებნის 1 მბ-ზე მეტი ზომის ყველა ფაილს ჩვენს პირად დირექტორიაში.
	find ∼ -type f -size 504c
ეს მოგვიძებნის ზუსტად 504 ბაიტის ზომის ფაილებს, თუ, რა თქმა უნდა, ასეთი
მოგვეპოვება.
	find ∼ -type f -size 5
რადგან აქ ზომის ერთეული არ არის მიწერილი, იგულისხმება b ერთეული (512
ბაიტიანი ბლოკი) და ასეთი ჩანაწერი მოგვიძებნის იმ ფაილებს, რომლებიც ზომით [4-5]
ბლოკს იკავებენ. ანუ რომელთა ზომები 4*512=2048 ბაიტსა და 5*512=2560 ბაიტს შორისაა
წარმოდგენილი. ამ ინტერვალში 2048 არ ჩაითვლება, ხოლო 2560 კი ჩაითვლება. n ბლოკის
მითითებისას მოგვიძებნის (n-1)*512-სა და n*512 ბაიტებს შორის არსებული ზომის
ფაილებს.
	find ∼ -size +2G -size -4G
ეს კი მოგვიძებნის ფაილებს, რომელთა ზომა 2 გბ-სა და 4 გბ-ს შორისაა.

	find . -type f -mmin -60
მოძებნის ყველა ფაილს, რომელიც შეიცვალა ბოლო 1 საათის (60 წუთის)
ნმავლობაში.
	find . -type f -mtime +5 -mtime -8
მოძებნის ყველა ფაილს, რომლებიც შეიცვალა ბოლო 5-8 დღეის განმავლობაში.
find ბრძანებას კიდევ ბევრი სხვა კრიტერიუმი აქვს. მათ სანახავად find-ის
ხელმძღვანელო გვერდი დაგვეხმარება. man find

როდესაც ერთი ბრძანების მეორსთან გადაბმა გვსურს, xargs ბრძანება ძალიან
სასარგებლო შეიძლება აღმოჩნდეს. ზოგადად, xargs კითხულობს მონაცემებს სტანდარტული
შესასვლელიდან, ამუშავებს და მათზე ასრულებს მოცემულ ბრძანებას, ნაგულისხმევი
მნიშვნელობით /bin/echo-ს. მოკლედ, შეგვიძლია ვთქვათ, რომ xargs თავად ქმნის
ბრძანებათა ხაზს.

ls *.txt | xargs wc

sed da grep


